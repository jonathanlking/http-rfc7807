-- |
-- Module:      Network.HTTP.RFC7807
-- Description: RFC7807 style response messages.
-- Copyright:   (c) 2020 Peter Tr≈°ko
-- License:     BSD3
--
-- Maintainer:  peter.trsko@gmail.com
-- Stability:   experimental
-- Portability: GHC specific language extensions.
--
-- <https://tools.ietf.org/html/rfc7807 RFC7807> style response messages.
module Network.HTTP.RFC7807
    (
      Rfc7807Error(..)
    , rfc7807Error

    -- * Encoding and Decoding
    --
    -- | Useful for defining your own encoding\/decoding instances.
    , ExtensionField(..)
    , EncodingOptions(..)
    , defaultEncodingOptions
    , toKeyValue
    , parseJSON

    -- * Usage Example
    --
    -- $newtypeExample
    )
  where

import Control.Applicative (pure)
import Data.Bool (Bool(False, True), (||), not, otherwise)
import Data.Eq (Eq)
import Data.Function (($), const)
import Data.Int (Int)
import Data.Maybe (Maybe(Nothing), isJust)
import Data.Monoid (Monoid, mconcat, mempty)
import Data.Proxy (Proxy(Proxy))
import Data.String (String)
import Data.Typeable (Typeable, typeRep)
import GHC.Generics (Generic)
import Text.Show (Show, show)

import Data.Aeson ((.:), (.:?), (.=))
import qualified Data.Aeson as Aeson
import qualified Data.Aeson.Types as Aeson (Parser)
import Data.Text (Text)


-- | Based on <https://tools.ietf.org/html/rfc7807 RFC7807> with few additional
-- fields.
data Rfc7807Error errorType errorInfo context = Rfc7807Error
    { type_ :: errorType
    -- ^ (required) A URI reference
    -- <https://tools.ietf.org/html/rfc3986 [RFC3986]> that identifies the
    -- problem type.  This specification encourages that, when dereferenced, it
    -- provide human-readable documentation for the problem type (e.g., using
    -- HTML
    -- <https://tools.ietf.org/html/rfc7807#ref-W3C.REC-html5-20141028 [W3C.REC-html5-20141028]>).
    -- When this member is not present, its value is assumed to be
    -- @\"about:blank\"@.
    --
    -- Consumers MUST use the @\"type\"@ string as the primary identifier for
    -- the problem type; the @\"title\"@ string is advisory and included only
    -- for users who are not aware of the semantics of the URI and do not
    -- have the ability to discover them (e.g., offline log analysis).
    -- Consumers SHOULD NOT automatically dereference the type URI.
    --
    -- Relative URIs are accepted; this means that they must be resolved
    -- relative to the document's base URI, as per
    -- <https://tools.ietf.org/html/rfc3986#section-5 [RFC3986], Section 5>.
    --
    -- In JSON this filed ins named only @\"type\"@.

    , title :: Maybe Text
    -- ^ (optional) A short, human-readable summary of the problem type.  It
    -- SHOULD NOT change from occurrence to occurrence of the problem, except
    -- for purposes of localization (e.g., using proactive content negotiation;
    -- see
    -- <https://tools.ietf.org/html/rfc7231#section-3.4 [RFC7231], Section 3.4>).
    --
    -- Consumers MUST use the @\"type\"@ string as the primary identifier for
    -- the problem type; the @\"title\"@ string is advisory and included only
    -- for users who are not aware of the semantics of the URI and do not
    -- have the ability to discover them (e.g., offline log analysis).
    -- Consumers SHOULD NOT automatically dereference the type URI.

    , status :: Maybe Int
    -- ^ (optional) The HTTP status code
    -- (<https://tools.ietf.org/html/rfc7231#section-6 [RFC7231], Section 6>)
    -- generated by the origin server for this occurrence of the problem.
    --
    -- If present, is only advisory; it conveys the HTTP status code used for
    -- the convenience of the consumer.  Generators MUST use the same status
    -- code in the actual HTTP response, to assure that generic HTTP software
    -- that does not understand this format still behaves correctly.  See
    -- <https://tools.ietf.org/html/rfc7807#section-5 [RFC7807], Section 5> for
    -- further caveats regarding its use.
    --
    -- Consumers can use the status member to determine what the original
    -- status code used by the generator was, in cases where it has been
    -- changed (e.g., by an intermediary or cache), and when message bodies
    -- persist without HTTP information.  Generic HTTP software will still use
    -- the HTTP status code.

    , detail :: Maybe Text
    -- ^ (optional) A human-readable explanation specific to this occurrence of
    -- the problem.
    --
    -- If present, ought to focus on helping the client correct the problem,
    -- rather than giving debugging information.  Consumers SHOULD NOT parse
    -- the "detail" member for information; extensions are more suitable and
    -- less error-prone ways to obtain such information.

    , instance_ :: Maybe Text
    -- ^ A URI reference that identifies the specific occurrence of the
    -- problem.  It may or may not yield further information if dereferenced.
    --
    -- Relative URIs are accepted; this means that they must be resolved
    -- relative to the document's base URI, as per
    -- <https://tools.ietf.org/html/rfc3986#section-5 [RFC3986], Section 5>.
    --
    -- In JSON this filed ins named only @\"instance\"@.

    , error_ :: Maybe errorInfo
    -- ^ (optional, extension) An additional representation of the error.  Lots
    -- of clients detect that the response is an error using simple algorithm
    -- of checking presence of the field @\"error\"@ that has non-@null@ value.
    --
    -- How the field is named in the resulting JSON object is controlled by
    -- 'extensionFieldName', but by default it is @\"error\"@.

    , context :: Maybe context
    -- ^ (optional, extension) Extra information for the purposes of debugging.
    --
    -- How the field is named in the resulting JSON object is controlled by
    -- 'extensionFieldName', but by default it is @\"context\"@.
    }
  deriving stock (Eq, Generic, Show)

-- | Constructor for 'Rfc7807Error' that set's only 'type_' and everything else
-- is set to 'Nothing'.
rfc7807Error :: errorType -> Rfc7807Error errorType errorInfo context
rfc7807Error type_ = Rfc7807Error
    { type_
    , title = Nothing
    , status = Nothing
    , detail = Nothing
    , instance_ = Nothing
    , error_ = Nothing
    , context = Nothing
    }

-- | Enum representing the extension fields 'error_' and 'context' that are not
-- defined by RFC7807.
data ExtensionField
    = ErrorField
    -- ^ Represents the name of the 'error_' field of 'Rfc7807Error' data type.
    | ContextField
    -- ^ Represents the name of the 'context' field of 'Rfc7807Error' data type.
  deriving stock (Eq, Generic, Show)

-- {{{ JSON Encoding ----------------------------------------------------------

-- | Encode 'Rfc7807Error' using default 'EncodingOptions':
-- @
-- Aeson.toJSON v = Aeson.object ('toKeyValue' 'defaultEncodingOptions' v)
-- Aeson.toEncoding v = Aeson.pairs ('toKeyValue' 'defaultEncodingOptions' v)
-- @
instance
    ( Aeson.ToJSON errorType
    , Aeson.ToJSON errorInfo
    , Aeson.ToJSON context
    ) => Aeson.ToJSON (Rfc7807Error errorType errorInfo context)
  where
    toJSON :: Rfc7807Error errorType errorInfo context -> Aeson.Value
    toJSON v = Aeson.Object (toKeyValue defaultEncodingOptions v)

    toEncoding :: Rfc7807Error errorType errorInfo context -> Aeson.Encoding
    toEncoding v = Aeson.pairs (toKeyValue defaultEncodingOptions v)

-- | Parameters that allow us to control certain aspects of how 'Rfc7807Error'
-- is encoded\/decoded to\/from JSON.
data EncodingOptions = EncodingOptions
    { omitNothingFields :: Bool
    -- ^ If set to @True@ (default), record fields of 'Rfc7807Error' with a
    -- 'Nothing' value will be omitted from the resulting object instead of
    -- being represented as @null@.
    --
    -- If set to @False@, the resulting JSON object will include those fields
    -- and the 'Nothing' value will be mapped to @null@ JSON value.
    --
    -- This setting is ignored by 'parse' function as respecting it would mean
    -- that even valid RFC7807 messages would fail to parse.

    , omitExtensionField :: ExtensionField -> Bool
    -- ^ If the function returns @True@ then the specified record field of
    -- 'Rfc7807Error' will be omitted entirely even if it contains
    -- 'Data.Maybe.Just' value.
    --
    -- If the function returns @False@ then the specified record field is
    -- included in the serialised output. However, if the value of that field
    -- is 'Nothing' and 'omitNothingFields' is set to @True@ then the field
    -- will once again be omitted from the resulting JSON object.
    --
    -- This setting can be used in a similar fashion as verbosity level. For
    -- example, we can omit these fields on production and have them enabled
    -- in testing or dev environments.
    --
    -- This setting is respected by 'parse' function, which will ignore
    -- extension fields for which the function returns @True@. Ignored
    -- extension fields will always be set to 'Nothing'.

    , extensionFieldName :: ExtensionField -> Text
    -- Fields 'error_' and 'context' are not defined by RFC7807 and as such
    -- their names may be adjusted depending on our particular needs and
    -- conventions. This function allows exactly that.
    --
    -- This setting is respected by 'parse' function, which will use this
    -- function when searching for extension fields in a JSON object.
    }
  deriving stock (Generic)

-- | Default 'EncodingOptions':
--
-- @
-- defaultEncodingOptions = 'EncodingOptions'
--     { 'omitNothingFields' = True
--     , 'omitExtensionField' = const False
--     }
-- @
defaultEncodingOptions :: EncodingOptions
defaultEncodingOptions = EncodingOptions
    { omitNothingFields = True
    , omitExtensionField = const False
    , extensionFieldName = \case
        ErrorField -> "error"
        ContextField -> "context"
    }

-- | Serialise 'Rfc7807Error' into a key-value pairs. This an abstract way how
-- to support both types of Aeson encodings.
--
-- @
-- 'Aeson.Object' . 'toKeyValue' 'defaultEncodingOptions'
--     ::  ( 'Aeson.ToJSON' errorType
--         , 'Aeson.ToJSON' errorInfo
--         , 'Aeson.ToJSON' context
--         )
--     => 'Rfc7807Error' errorType errorInfo context
--     -> 'Aeson.Value'
--
-- 'Aeson.pairs' . 'toKeyValue' 'defaultEncodingOptions'
--     ::  ( 'Aeson.ToJSON' errorType
--         , 'Aeson.ToJSON' errorInfo
--         , 'Aeson.ToJSON' context
--         )
--     => 'Rfc7807Error' errorType errorInfo context
--     -> 'Aeson.Encoding'
-- @
toKeyValue
    :: forall kv errorType errorInfo context
    .   ( Aeson.ToJSON errorType
        , Aeson.ToJSON errorInfo
        , Aeson.ToJSON context
        , Aeson.KeyValue kv
        , Monoid kv
        )
    => EncodingOptions
    -> Rfc7807Error errorType errorInfo context
    -> kv
toKeyValue EncodingOptions{..} Rfc7807Error{..} = mconcat
    [ "type" .= type_
    , field "title" title
    , field "status" status
    , field "detail" detail
    , field "instance" instance_
    , extField ErrorField error_
    , extField ContextField context
    ]
  where
    field :: Aeson.ToJSON a => Text -> Maybe a -> kv
    field name value =
        mwhen (not omitNothingFields || isJust value)
            (name .= value)

    extField :: Aeson.ToJSON a => ExtensionField -> Maybe a -> kv
    extField name value =
        mwhen (not (omitExtensionField name))
            $ field (extensionFieldName name) value

    mwhen :: Bool -> kv -> kv
    mwhen p kv = if p then kv else mempty

-- }}} JSON Encoding ----------------------------------------------------------

-- {{{ JSON Decoding ----------------------------------------------------------

-- | Decode 'Rfc7807Error' using default 'EncodingOptions':
-- @
-- Aeson.parseJSON = 'parseJSON' 'defaultEncodingOptions'
-- @
instance
    ( Aeson.FromJSON errorType
    , Aeson.FromJSON errorInfo
    , Aeson.FromJSON context
    , Typeable errorType
    , Typeable errorInfo
    , Typeable context
    )
    => Aeson.FromJSON (Rfc7807Error errorType errorInfo context)
  where
    parseJSON
        :: Aeson.Value
        -> Aeson.Parser (Rfc7807Error errorType errorInfo context)
    parseJSON = parseJSON defaultEncodingOptions

-- | Parse JSON value into 'Rfc7807Error'.
parseJSON
    :: forall errorType errorInfo context
    .   ( Aeson.FromJSON errorType
        , Aeson.FromJSON errorInfo
        , Aeson.FromJSON context
        , Typeable errorType
        , Typeable errorInfo
        , Typeable context
        )
    => EncodingOptions
    -> Aeson.Value
    -> Aeson.Parser (Rfc7807Error errorType errorInfo context)
parseJSON EncodingOptions{omitExtensionField, extensionFieldName} =
    Aeson.withObject typeName \o -> do
        type_ <- o .: "type"
        title <- o .:? "title"
        status <- o .:? "status"
        detail <- o .:? "detail"
        instance_ <- o .:? "instance"
        error_ <- extField o ErrorField
        context <- extField o ContextField

        pure Rfc7807Error
            { type_
            , title
            , status
            , detail
            , instance_
            , error_
            , context
            }
  where
    typeName :: String
    typeName =
        show (typeRep (Proxy @(Rfc7807Error errorType errorInfo context)))

    extField
        :: Aeson.FromJSON a
        => Aeson.Object
        -> ExtensionField
        -> Aeson.Parser (Maybe a)
    extField o name
      | omitExtensionField name = pure Nothing
      | otherwise               = o .:? extensionFieldName name

-- }}} JSON Decoding ----------------------------------------------------------

-- $newtypeExample
--
-- While it is possible to use 'Rfc7807Error' directly, using newtype allows to
-- be more flexible with how things are encoded.
--
-- @
-- data ErrorType
--     = DocumentNotFound
--     {- ... -}
--
-- instance 'Aeson.ToJSON' ErrorType where
--     toJSON = \\case
--         DocumentNotFound ->
--             'Aeson.Text' \"https://example.com/docs/error#document-not-found\"
--         {- ... -}
--
-- newtype ErrorResponse = ErrorResponse
--     { errorResponse :: 'Rfc7807Error' ErrorType () ()
--     }
--
-- errorResponseEncodingOptions :: 'EncodingOptions'
-- errorResponseEncodingOptions = 'defaultEncodingOptions'
--     { 'omitExtensionField' = const True
--     }
--
-- instance 'Aeson.ToJSON' ErrorResponse where
--     'Aeson.toJSON' :: ErrorResponse -> 'Aeson.Value'
--     'Aeson.toJSON' ErrorResponse{..} =
--          'Aeson.object' . 'toKeyValue' errorResponseEncodingOptions
--     {- ... -}
--
-- instance 'Aeson.FromJSON' ErrorResponse where
--     'Aeson.parseJSON' :: ErrorResponse -> 'Aeson.Value'
--     'Aeson.parseJSON' =
--          ErrorResponse <$> 'parseJSON' errorResponseEncodingOptions
-- @
